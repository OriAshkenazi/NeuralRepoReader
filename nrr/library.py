import os
import git
import ast
from openai_api import call_gpt4

class FunctionOrClass: # also called elements
    def __init__(self, name, type_, description, code):
        self.name = name
        self.type = type_  # "function" or "class"
        self.description = description
        self.code = code
        self.description_gpt = ""  # description generated by GPT-4

    def generate_description(self):
        prompt = f"Let's dive into a {self.type} named '{self.name}'. Based on its code, can you tell me its purpose?\n{self.code}"
        self.description_gpt = call_gpt4(prompt)  # replace call_gpt4 with your GPT-4 function

class Module:
    def __init__(self, name, code):
        self.name = name
        self.code = code
        self.elements = []  # this will contain instances of FunctionOrClass
        self.description_gpt = ""  # description generated by GPT-4

    def add_element(self, element):
        self.elements.append(element)

    def generate_description(self):
        for element in self.elements:
            element.generate_description()
        element_descriptions = "\n".join([f"{element.type.capitalize()}: {element.description_gpt}" for element in self.elements])
        prompt = f"We are looking at a module named '{self.name}'. It consists of the following:\n{element_descriptions}\nCan you summarize what the entire module does based on these elements?\n{self.code}"
        self.description_gpt = call_gpt4(prompt)  # replace call_gpt4 with your GPT-4 function

class File:
    def __init__(self, name, code):
        self.name = name
        self.code = code
        self.modules = []  # this will contain an instance of Module
        self.description_gpt = ""  # description generated by GPT-4

    def set_module(self, module):
        self.modules.append(module)

    def generate_description(self):
        for module in self.modules:
            module.generate_description()
        module_descriptions = "\n".join([f"Module: {module.description_gpt}" for module in self.modules])
        prompt = f"Let's examine a Python file named '{self.name}'. It comprises the following modules:\n{module_descriptions}\nCan you give a summary of what the entire file accomplishes?\n{self.code}"
        self.description_gpt = call_gpt4(prompt)  # replace call_gpt4 with your GPT-4 function

class Folder:
    def __init__(self, name):
        self.name = name
        self.files = []
        self.folders = []
        self.description_gpt = ""  # description generated by GPT-4

    def add_file(self, file):
        self.files.append(file)

    def add_folder(self, folder):
        self.folders.append(folder)

    def generate_description(self):
        for file in self.files:
            file.generate_description()
        for folder in self.folders:
            folder.generate_description()
        file_descriptions = "\n".join([f"File: {file.description_gpt}" for file in self.files])
        folder_descriptions = "\n".join([f"Sub-folder: {folder.description_gpt}" for folder in self.folders])
        prompt = f"We're exploring a folder named '{self.name}'. It contains these files and sub-folders:\n{file_descriptions}\n{folder_descriptions}\nCan you summarize the overall functionality of this folder?"
        self.description_gpt = call_gpt4(prompt)  # replace call_gpt4 with your GPT-4 function

class Library:
    def __init__(self, name, repo_url):
        self.name = name
        self.root = os.path.join(os.getcwd(), 'repos', name)
        os.makedirs(self.root, exist_ok=True)
        self.files = []
        self.folders = []
        self._clone_repo(repo_url)
        self._populate()
        self.description_gpt = ""  # description generated by GPT-4

    def _clone_repo(self, repo_url):
        if not os.listdir(self.root):
            git.Repo.clone_from(repo_url, self.root)

    def _populate(self):
        for root_, dirs, files in os.walk(self.root, followlinks=False): # Disable following symbolic links
            # If the current directory is a symbolic link, continue with the next iteration
            if os.path.islink(root_):
                continue
            if '.git' in dirs: 
                dirs.remove('.git')  # don't visit .git directories
            relative_root = os.path.relpath(root_, self.root)
            if relative_root == ".":
                current_folder = self
            else:
                current_folder = Folder(relative_root)
                self.folders.append(current_folder)

            for file_name in files:
                if file_name.endswith(".py"):
                    file_path = os.path.join(root_, file_name)
                    if os.path.islink(file_path):
                        continue
                    file = self._create_file(file_path)
                    current_folder.files.append(file)

    def _create_file(self, path):
        file_name = os.path.basename(path)
        with open(path, 'r') as file_obj:
            file_code = file_obj.read()
        file = File(file_name, file_code)
        # Use AST to iterate over all classes and functions in the file
        tree = ast.parse(file_code)
        # Create a module and add it to the file
        module = Module(file_name, file_code)
        file.set_module(module)
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
                name = node.name
                type_ = type(node).__name__
                # Extracting the actual code from the starting and ending line numbers
                element_code = '\n'.join(file_code.split('\n')[node.lineno - 1:node.end_lineno])
                description = ast.get_docstring(node)
                element = FunctionOrClass(name, type_, description, element_code)
                module.add_element(element)
        return file


    def get_overview(self):
        # Generating GPT-4 descriptions for files in the root of the library
        for file in self.files:
            file.generate_description()
        # Generating GPT-4 descriptions for files in each folder
        folders_to_process = self.folders.copy()  # Copy the list to avoid modifying it while iterating
        while folders_to_process:
            current_folder = folders_to_process.pop(0)
            for file in current_folder.files:
                file.generate_description()
            # Add any sub-folders to our list to process next
            folders_to_process.extend(current_folder.folders)
        # Constructing the overview
        overview = f"Library {self.name} contains:\n"
        folders = [(folder, 1) for folder in self.folders]  # (folder, depth)
        files = [file for file in self.files]
        while folders:
            folder, depth = folders.pop(0)
            overview += "    " * depth + f"Folder: {folder.name}\n"
            # Add this folder's files and sub-folders to our lists
            files.extend(folder.files)
            folders.extend((sub_folder, depth + 1) for sub_folder in folder.folders)
        # Constructing the GPT-4 input prompt for library description
        gpt_prompt = f"This is an overview of the Python library named {self.name}. It consists of the following files and their respective modules and elements: "
        for file in files:
            gpt_prompt += f"\nFile: {file.name} - {file.description_gpt}"
            for module in file.modules:
                gpt_prompt += f"\n    Module: {module.name} - {module.description_gpt}"
                for element in module.elements:
                    gpt_prompt += f"\n        {element.type.capitalize()}: {element.name} - {element.description_gpt}"
        gpt_prompt += "\nPlease describe the overall functionality and purpose of this library."
        # Calling GPT-4 for library description
        self.description_gpt = None #implement
        # Including the GPT-4 description in the library overview
        overview += f"\n\nGPT-4 Description of the Library: {self.description_gpt}"
        return overview